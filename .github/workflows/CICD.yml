name: CICD

# spell-checker:ignore CICD MSVC MacOS SHAs buildable clippy esac gnueabihf mkdir musl rustfmt softprops toolchain

env:
  PROJECT_NAME: lsd

on: [push, pull_request]

jobs:
  style:
    name: Style
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        os: [ ubuntu-latest, macos-latest, windows-latest ]
    steps:
    - uses: actions/checkout@v1
    - name: Install `rust` toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
        profile: minimal # minimal component installation (ie, no documentation)
        components: rustfmt, clippy
    - name: "`fmt` testing"
      uses: actions-rs/cargo@v1
      with:
        command: fmt
        args: --all -- --check
    - name: "`clippy` testing"
      uses: actions-rs/cargo@v1
      with:
        command: clippy
        args: -- -D warnings

  build:
    name: Build
    runs-on: ${{ matrix.os }}
    strategy:
      fail-fast: false
      matrix:
        target:
          - arm-unknown-linux-gnueabihf
          - i686-unknown-linux-gnu
          - i686-unknown-linux-musl
          - x86_64-unknown-linux-gnu
          - x86_64-unknown-linux-musl
          # - i686-apple-darwin ## (deprecated/un-buildable)
          - x86_64-apple-darwin
          # - i686-pc-windows-gnu ## gnu targets on Windows are broken when alternate `gcc` compilers are in the PATH (refs: <https://github.com/rust-lang/rust/issues/47048>, <https://github.com/rust-lang/rust/issues/53454>, <https://github.com/rust-lang/cargo/issues/6754>)
          - i686-pc-windows-msvc
          # - x86_64-pc-windows-gnu ## gnu targets on Windows are broken when alternate `gcc` compilers are in the PATH (refs: <https://github.com/rust-lang/rust/issues/47048>, <https://github.com/rust-lang/rust/issues/53454>, <https://github.com/rust-lang/cargo/issues/6754>)
          - x86_64-pc-windows-msvc
        include:
          - target: arm-unknown-linux-gnueabihf
            os: ubuntu-latest
            cross: true
          - target: i686-unknown-linux-gnu
            os: ubuntu-latest
            cross: true
          - target: i686-unknown-linux-musl
            os: ubuntu-latest
            cross: true
          - target: x86_64-unknown-linux-gnu
            os: ubuntu-latest
            cross: true
          - target: x86_64-unknown-linux-musl
            os: ubuntu-latest
            cross: true
          - target: i686-apple-darwin
            os: macos-latest
          - target: x86_64-apple-darwin
            os: macos-latest
          - target: i686-pc-windows-gnu
            os: windows-latest
          - target: i686-pc-windows-msvc
            os: windows-latest
          - target: x86_64-pc-windows-gnu
            os: windows-latest
          - target: x86_64-pc-windows-msvc
            os: windows-latest
    steps:
    - uses: actions/checkout@v1
    - name: Install any prerequisites
      shell: bash
      run: |
        case ${{ matrix.target }} in
          arm-unknown-linux-gnueabihf) sudo apt-get -y update ; sudo apt-get -y install gcc-arm-linux-gnueabihf ;;
        esac
    - name: Initialize workflow variables
      id: vars
      shell: bash
      run: |
        # staging directory
        STAGING='_staging'
        echo set-output name=STAGING::${STAGING}
        echo ::set-output name=STAGING::${STAGING}
        # determine EXE suffix
        EXE_suffix="" ; case ${{ matrix.target }} in *-pc-windows-*) EXE_suffix=".exe" ;; esac;
        echo set-output name=EXE_suffix::${EXE_suffix}
        echo ::set-output name=EXE_suffix::${EXE_suffix}
        # parse commit reference info
        REF_NAME=${GITHUB_REF#refs/*/}
        unset REF_BRANCH ; case ${GITHUB_REF} in refs/heads/*) REF_BRANCH=${GITHUB_REF#refs/heads/} ;; esac;
        unset REF_TAG ; case ${GITHUB_REF} in refs/tags/*) REF_TAG=${GITHUB_REF#refs/tags/} ;; esac;
        REF_SHAS=${GITHUB_SHA:0:8}
        echo set-output name=REF_NAME::${REF_NAME}
        echo set-output name=REF_BRANCH::${REF_BRANCH}
        echo set-output name=REF_TAG::${REF_TAG}
        echo set-output name=REF_SHAS::${REF_SHAS}
        echo ::set-output name=REF_NAME::${REF_NAME}
        echo ::set-output name=REF_BRANCH::${REF_BRANCH}
        echo ::set-output name=REF_TAG::${REF_TAG}
        echo ::set-output name=REF_SHAS::${REF_SHAS}
        # package name
        PKG_suffix=".tar.gz" ; case ${{ matrix.target }} in *-pc-windows-*) PKG_suffix=".zip" ;; esac;
        PKG_BASENAME=${PROJECT_NAME}-${REF_TAG:-$REF_SHAS}-${{ matrix.target }}
        PKG_NAME=${PKG_BASENAME}${PKG_suffix}
        echo set-output name=PKG_suffix::${PKG_suffix}
        echo set-output name=PKG_BASENAME::${PKG_BASENAME}
        echo set-output name=PKG_NAME::${PKG_NAME}
        echo ::set-output name=PKG_suffix::${PKG_suffix}
        echo ::set-output name=PKG_BASENAME::${PKG_BASENAME}
        echo ::set-output name=PKG_NAME::${PKG_NAME}
        # deployable tag? (ie, leading "vM" or "M"; M == version number)
        unset DEPLOY ; if [[ $REF_TAG =~ ^[vV]?[0-9].* ]]; then DEPLOY=true ; fi
        echo set-output name=DEPLOY::${DEPLOY}
        echo ::set-output name=DEPLOY::${DEPLOY}
        # target-specific options
        # * test only binary for arm-type targets
        unset CARGO_TEST_OPTIONS ; case ${{ matrix.target }} in arm-*) CARGO_TEST_OPTIONS="--bin ${PROJECT_NAME}" ;; esac;
        echo set-output name=CARGO_TEST_OPTIONS::${CARGO_TEST_OPTIONS}
        echo ::set-output name=CARGO_TEST_OPTIONS::${CARGO_TEST_OPTIONS}
        # * strip executable?
        STRIP="strip" ; case ${{ matrix.target }} in arm-unknown-linux-gnueabihf) STRIP="arm-linux-gnueabihf-strip" ;; *-pc-windows-*) STRIP="" ;; esac;
        echo set-output name=STRIP::${STRIP}
        echo ::set-output name=STRIP::${STRIP}
    - name: Create all needed build/work directories
      shell: bash
      run: |
        mkdir -p '${{ steps.vars.outputs.STAGING }}'
        mkdir -p '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}'
        mkdir -p '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/autocomplete'
    - name: Install `rust` toolchain
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        target: ${{ matrix.target }}
        override: true
        profile: minimal # minimal component installation (ie, no documentation)
    - name: Build
      uses: actions-rs/cargo@v1
      with:
        use-cross: ${{ matrix.cross }}
        command: build
        args: --release --target=${{ matrix.target }}
    - name: Test
      uses: actions-rs/cargo@v1
      with:
        use-cross: ${{ matrix.cross }}
        command: test
        args: --target=${{ matrix.target }} ${{ steps.vars.outputs.CARGO_TEST_OPTIONS}}
    - name: Archive executable artifacts
      uses: actions/upload-artifact@master
      with:
        name: ${{ env.PROJECT_NAME }}-${{ matrix.target }}
        path: target/${{ matrix.target }}/release/${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}
    - name: Package
      shell: bash
      run: |
        # binary
        cp 'target/${{ matrix.target }}/release/${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/'
        # `strip` binary (if needed)
        if [ -n "${{ steps.vars.outputs.STRIP }}" ]; then "${{ steps.vars.outputs.STRIP }}" '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/${{ env.PROJECT_NAME }}${{ steps.vars.outputs.EXE_suffix }}' ; fi
        # README and LICENSE
        cp README.md '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/'
        cp LICENSE '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/'
        # autocomplete
        cp 'target/${{ matrix.target }}/release/build/${{ env.PROJECT_NAME }}-'*/'out/${{ env.PROJECT_NAME }}.bash' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/autocomplete/${{ env.PROJECT_NAME }}.bash-completion'
        cp 'target/${{ matrix.target }}/release/build/${{ env.PROJECT_NAME }}-'*/'out/${{ env.PROJECT_NAME }}.fish' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/autocomplete/'
        cp 'target/${{ matrix.target }}/release/build/${{ env.PROJECT_NAME }}-'*/'out/_${{ env.PROJECT_NAME }}' '${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_BASENAME }}/autocomplete/'
        # base compressed package
        pushd '${{ steps.vars.outputs.STAGING }}/' >/dev/null
        case ${{ matrix.target }} in
          *-pc-windows-*) 7z -y a '${{ steps.vars.outputs.PKG_NAME }}' '${{ steps.vars.outputs.PKG_BASENAME }}'/* | tail -2 ;;
          *) tar czf '${{ steps.vars.outputs.PKG_NAME }}' '${{ steps.vars.outputs.PKG_BASENAME }}'/* ;;
        esac;
        popd >/dev/null
    - name: Publish
      uses: softprops/action-gh-release@v1
      if: steps.vars.outputs.DEPLOY
      with:
        files: |
          ${{ steps.vars.outputs.STAGING }}/${{ steps.vars.outputs.PKG_NAME }}
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
